/**
 * Version Data Generator
 * 
 * Parses packages/beacon-ui/CHANGELOG.md and generates structured TypeScript data
 * for use in the Releases and Changelog pages.
 */

import * as fs from "fs";
import * as path from "path";

const PROJECT_ROOT = path.resolve(__dirname, "..");
const CHANGELOG_PATH = path.join(PROJECT_ROOT, "packages", "beacon-ui", "CHANGELOG.md");
const OUTPUT_PATH = path.join(PROJECT_ROOT, "src", "constants", "version-data.ts");

export interface ChangeItem {
  description: string;
}

export interface VersionEntry {
  version: string;
  date: string;
  added?: ChangeItem[];
  changed?: ChangeItem[];
  fixed?: ChangeItem[];
  deprecated?: ChangeItem[];
  removed?: ChangeItem[];
  security?: ChangeItem[];
}

/**
 * Parse CHANGELOG.md and extract version entries
 */
function parseChangelog(): VersionEntry[] {
  const content = fs.readFileSync(CHANGELOG_PATH, "utf-8");
  const entries: VersionEntry[] = [];
  
  // Match version headers: ## [3.2.0] - 2025-01-02
  const versionRegex = /^## \[([\d.]+)\]\s*-\s*(\d{4}-\d{2}-\d{2})/gm;
  const lines = content.split("\n");
  
  let currentVersion: VersionEntry | null = null;
  let currentCategory: keyof VersionEntry | null = null;
  let inVersionSection = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check for version header
    const versionMatch = line.match(/^## \[([\d.]+)\]\s*-\s*(\d{4}-\d{2}-\d{2})/);
    if (versionMatch) {
      // Save previous version if exists
      if (currentVersion) {
        entries.push(currentVersion);
      }
      
      // Start new version entry
      currentVersion = {
        version: versionMatch[1],
        date: versionMatch[2],
      };
      inVersionSection = true;
      currentCategory = null;
      continue;
    }
    
    // Stop parsing if we hit the "Version History" section or separator
    if (line.startsWith("## Version History") || line.trim() === "---") {
      if (currentVersion) {
        entries.push(currentVersion);
      }
      break;
    }
    
    if (!inVersionSection || !currentVersion) {
      continue;
    }
    
    // Check for category headers: ### Added, ### Changed, etc.
    const categoryMatch = line.match(/^###\s+(Added|Changed|Fixed|Deprecated|Removed|Security)$/);
    if (categoryMatch) {
      const categoryName = categoryMatch[1].toLowerCase() as keyof VersionEntry;
      currentCategory = categoryName;
      // Initialize array if it doesn't exist
      const categoryValue = currentVersion[categoryName];
      if (!categoryValue || !Array.isArray(categoryValue)) {
        (currentVersion[categoryName] as ChangeItem[]) = [];
      }
      continue;
    }
    
    // Parse list items under categories
    if (currentCategory && line.trim().startsWith("-")) {
      const description = line.trim().substring(1).trim();
      if (description) {
        const categoryValue = currentVersion[currentCategory];
        if (categoryValue && Array.isArray(categoryValue)) {
          categoryValue.push({ description });
        }
      }
    }
  }
  
  // Don't forget the last version
  if (currentVersion && !entries.find(e => e.version === currentVersion!.version)) {
    entries.push(currentVersion);
  }
  
  return entries;
}

/**
 * Generate TypeScript file with version data
 */
function generateVersionDataFile(entries: VersionEntry[]): void {
  const versionDataString = JSON.stringify(entries, null, 2);
  
  const fileContent = `/**
 * Version Data
 * 
 * ⚠️ AUTO-GENERATED: This file is automatically generated from packages/beacon-ui/CHANGELOG.md
 * Do not edit manually. Run \`npm run sync:version\` to regenerate.
 */

export interface ChangeItem {
  description: string;
}

export interface VersionEntry {
  version: string;
  date: string;
  added?: ChangeItem[];
  changed?: ChangeItem[];
  fixed?: ChangeItem[];
  deprecated?: ChangeItem[];
  removed?: ChangeItem[];
  security?: ChangeItem[];
}

const versionData: VersionEntry[] = ${versionDataString};

/**
 * Get all version entries (newest first)
 */
export function getVersionHistory(): VersionEntry[] {
  return versionData;
}

/**
 * Get the current (latest) version entry
 */
export function getCurrentVersion(): VersionEntry | null {
  return versionData.length > 0 ? versionData[0] : null;
}

/**
 * Get the previous version entry
 */
export function getPreviousVersion(): VersionEntry | null {
  return versionData.length > 1 ? versionData[1] : null;
}

/**
 * Get changes since the last version
 * Returns the current version's changes if available
 */
export function getChangesSinceLastVersion(): VersionEntry | null {
  return getCurrentVersion();
}

/**
 * Get a specific version entry by version string
 */
export function getVersionEntry(version: string): VersionEntry | null {
  return versionData.find(entry => entry.version === version) || null;
}
`;

  fs.writeFileSync(OUTPUT_PATH, fileContent, "utf-8");
  console.log(`✓ Generated ${OUTPUT_PATH}`);
}

// Main execution
try {
  const entries = parseChangelog();
  if (entries.length === 0) {
    console.warn("⚠ No version entries found in CHANGELOG.md");
  } else {
    console.log(`Found ${entries.length} version entries`);
    generateVersionDataFile(entries);
  }
} catch (error) {
  console.error("Error generating version data:", error);
  process.exit(1);
}

